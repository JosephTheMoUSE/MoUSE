"""Module implementing GAC USVs search."""
from functools import partial
from typing import Callable, List, Optional, Dict
import copy

import numpy as np
from skimage import segmentation, morphology
from tqdm import tqdm

from mouse.utils import data_util
from mouse.utils import sound_util


def eroded_level_set_generator(threshold: float) -> Callable[[np.ndarray], np.ndarray]:
    """Create function generating eroded level set.

    Eroded level set is generated by setting level set values to 0 if their
    corresponding array values are below `threshold`. Value can be set to 0 only if it
    can be reached by a path of 0-valued array elements. The path must start at array
    edge.

    Parameters
    ----------
    threshold : float
        Threshold for erosion.

    Returns
    -------
    Callable[[np.ndarray], np.ndarray]
        Function for calculating level set.
    """

    def _level_set(image: np.ndarray):
        mask = image <= threshold
        seed = np.ones_like(mask, dtype=np.int8)
        mask[:, 0] = 0
        mask[:, -1] = 0
        mask[0, :] = 0
        mask[-1, :] = 0
        seed[:, 0] = 0
        seed[:, -1] = 0
        seed[0, :] = 0
        seed[-1, :] = 0
        return morphology.reconstruction(seed, mask, method="erosion")

    return _level_set


def ones_level_set(image: np.ndarray) -> np.ndarray:
    """Calculate shape based level set.

    Resulting level set is an array filled with ones. Only edge values are set to 0.

    Parameters
    ----------
    image : np.ndarray
        Input image for level set calculation.

    Returns
    -------
    np.ndarray
        Level set.
    """
    level_set = np.ones_like(image, dtype=np.int8)
    level_set[:, 0] = 0
    level_set[:, -1] = 0
    level_set[0, :] = 0
    level_set[-1, :] = 0

    return level_set


def find_USVs(spec: sound_util.SpectrogramData,
              min_side_length=1,
              filter=True,
              preprocessing_fn: Optional[Callable] = None,
              level_set: Callable = ones_level_set,
              tqdm_kwargs: Optional[Dict] = None,
              **kwargs) -> List[data_util.SqueakBox]:
    """Find USVs on spectrogram `spec` using GAC.

    Parameters
    ----------
    spec : sound_util.SpectrogramData
        A spectrogram that is searched for USVs.
    min_side_length : int
        A parameter passed to `mouse.segmentation.find_bounding_boxes`.
    filter : bool
        Tells whether or not to filter USVs' bounding boxes. The filtering
        uses `mouse.data_util.filter_boxes`.
    preprocessing_fn : Callable
        Function for preprocessing the spectrogram `spec`.
    level_set : Callable
        Function for generating initial level set based on preprocessed `spec`.
    kwargs
        kwargs are passed to `morphological_geodesic_active_contour` from
        `skimage.segmentation`.

    Returns
    -------
    List[data_util.SqueakBox]
        List of detected USVs' bounding boxes.
    """
    _kwargs = copy.deepcopy(kwargs)

    if preprocessing_fn is None:
        preprocessing_fn = partial(segmentation.inverse_gaussian_gradient,
                                   sigma=5,
                                   alpha=100)
    for arg, val in [
        ("num_iter", 230),
        ("smoothing", 0),
        ("threshold", 0.9),
        ("balloon", -1),
    ]:
        if arg not in _kwargs:
            _kwargs[arg] = val

    _spec = preprocessing_fn(spec.spec.numpy())

    level_set_init = level_set(_spec)

    tqdm_kwargs = tqdm_kwargs if tqdm_kwargs else {}
    with tqdm(total=_kwargs["num_iter"], **tqdm_kwargs) as pbar:
        if 'iter_callback' in _kwargs:
            callback = _kwargs['iter_callback']

            def _iter_callback(level_set):
                callback(level_set)
                pbar.update(1)

            _kwargs['iter_callback'] = _iter_callback

        # Ensure no 'iterations' keyword is passed
        if 'iterations' in _kwargs:
            del _kwargs['iterations']

        level_set_result = segmentation.morphological_geodesic_active_contour(
            _spec, init_level_set=level_set_init, **_kwargs)

    boxes = data_util.find_bounding_boxes(level_set_result,
                                          min_side_length=min_side_length)

    if filter:
        return data_util.filter_boxes(spec, boxes)
    else:
        return boxes

